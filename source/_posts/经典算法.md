---
title: git命令
date: 2019-12-25 19:52:20
categories:
- 算法
tags:
- 算法
---
# 经典排序算法

## 冒泡排序
冒泡排序，相邻2数比较交换位置
```
func bubbleSort(arr []int)  {
   for i:=0;i<num-1 ; i++ {
      for j := i+1; j < num ; j++ {
         if arr[i] < arr[j] {
            arr[i], arr[j] = arr[j], arr[i]
         }
      }
   }
}
```
## 选择排序
是最基本的O(n^2)的排序算法。选择排序的内循环是遍历一组未排过序的数组。

先假设第一个数为最小数，与剩余len-1个数比较，确定最小数的下标，将最小数和第一个元素交换位置。然后进行下一轮遍历（确定第2~n小的数）
```
func selectSort(arr []int)  {
   for i:=0 ; i<len(arr)-1 ; i++ {
      max := i //最小或最大元素的下标
      for j := i+1 ; j < len(arr) ; j++ {
         if arr[j] > arr[max] {
            max = j
         }
      }
      arr[i], arr[max] = arr[max], arr[i]
   }
}
```

### 冒泡排序和选择排序的区别
区别主要在交换的方式上
每一轮都把最大或最小的元素筛选出来放在相应的位置上
这是相同的
但是
对于每一轮
冒泡法每次比较和移动相邻的两项
而选择排序每次交换当前项和第n项

总的来说，两种排序比较的次数是相同的
但交换的次数，选择排序是更少的
虽然两者的时间复杂度都是 O(n^2)
但通常，选择排序更快一点
冒泡排序是每一次都可能要交换
而选择排序是在比较时记下a[i]的位置 最后来交换
所以他们的交换过程是不一样的 而查找的过程是一样的
效率不会比冒泡的低…


## 插入排序
也是一个时间复杂度平均为O(n^2)的算法。插入排序的内循环是遍历一组已排过序的数组。

假设从小到大排序的m个元素，第m+1个元素分别和第m个到第1个元素对比，若m+1大于m，则结束该循环，将m+2元素插入m+1有序数组；若m+1小于m元素，将m+1与m元素交换位置，再比较m元素和m-1元素的大小直到确定顺序。

插入排序相比选择排序不同的是，第二层循环可以提前结束，即与前一位比较时，比前一位大，就说明此时元素已经在正确的位置了，直接进行下一个循环。由于可以提前结束内循环，所以在最好的情况下，插入排序的时间复杂度可以达到O(n)的级别。

由此可见，若数组为有序，则插入排序效率较高，若数组无序，则插入效率较低。改进插入排序算法可以使用二分法等。
```
func insertSort(arr []int) {
	for i:=0;i<len(arr) ; i++ {
		selected := arr[i]
		for j:= i-1; j > 0 && arr[j] > selected ; j-- {
				arr[j], arr[j+1] = arr[j+1], arr[j]
		}
	}
	return
}
```
## 快速排序
```
func fastSort(data []int) {
	partition(data, 0, len(data)-1)
}

func partition(data []int, low, high int) {
	if low < high {
		temp := data[(low+high)/2]
		i, j := low, high
		for i <= j {
			for data[i] > temp {
				i++
			}
			for data[j] < temp {
				j--
			}
			if i <= j {
				data[i], data[j] = data[j], data[i]
				i++
				j--
			}
		}
		if low < j {
			partition(data, low, j)
		}
		if i < high {
			partition(data, i, high)
		}
	}
}
```
## 希尔排序
```
```
## 合并排序
```
```
## 堆排序
```
```
## 基础排序
```
```

## 算法复杂度
|算法|最好情况|最坏情况|复杂度|
|:---|:---|:---|:---|
|选择排序|交换0次，比较n(n-1)/2次|交换N次|O(n^2)|
|插入排序|交换0次，比较N-1次|交换n(n-1)/2次，比较n(n-1)/2次|O(n^2)|

待续
[原文链接](https://blog.csdn.net/eson_15/article/details/51144079)

[TOC]

二叉搜索树是个很好的数据结构，可以快速地找到一个给定关键字的数据项，并且可以快速地插入和删除数据项。但是二叉搜索树有个很麻烦的问题，
如果树中插入的是随机数据，则执行效果很好，但如果插入的是有序或者逆序的数据，那么二叉搜索树的执行速度就变得很慢。
因为当插入数值有序时，二叉树就是非平衡的了，排在一条线上，其实就变成了一个链表……它的快速查找、插入和删除指定数据项的能力就丧失了。

为了能以较快的时间 O(logN) 来搜索一棵树，需要保证树总是平衡的（或者至少大部分是平衡的），这就是说对树中的每个节点在它左边的后代数目和在它右边的后代
数目应该大致相等。红-黑树的就是这样的一棵平衡树，对一个要插入的数据项，插入例程要检查会不会破坏树的特征，如果破坏了，程序就会进行纠正，根据需要改变树的
结构，从而保持树的平衡。那么红-黑树都有哪些特征呢

# 红黑树性质

> 1. 节点是红色或黑色。
> 2. 根是黑色。
> 3. 所有叶子都是黑色（叶子是NIL节点）。
> 4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
> 5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

# 平衡性的修正

红-黑树主要通过三种方式对平衡进行修正，**改变节点颜色**、**左旋**和**右旋**。这看起来有点抽象，我们分别来介绍它们。

## 左旋

![Image](https://img-blog.csdnimg.cn/20190110125840327.gif)

## 右旋

![Image](https://img-blog.csdnimg.cn/20190110125902690.gif)

 左旋的具体实现
 ```
/*************对红黑树节点x进行左旋操作 ******************/
/*
 * 左旋示意图：对节点x进行左旋
 *     p                       p
 *    /                       /
 *   x                       y
 *  / \                     / \
 * lx  y      ----->       x  ry
 *    / \                 / \
 *   ly ry               lx ly
 * 左旋做了三件事：
 * 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时)
 * 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)
 * 3. 将y的左子节点设为x，将x的父节点设为y
 */

func (x *node) leftRotate(tree *RBTree) {
	if x == nil || x.right == nil { //x的右子节点为nil，无法左旋
		return
	}
	p, y, ly := x.parent, x.right, x.right.left
	y.parent, y.left, x.parent, x.right = p, x, y, ly
	if p == nil {
		tree.root = y
	} else if p.left == x {
		p.left = y
	} else {
		p.right = y
	}
	return
}
```

左旋的具体实现

```
/*************对红黑树节点y进行右旋操作 ******************/
/*
 * 右旋示意图：对节点y进行右旋
 *        p                   p
 *       /                   /
 *      y                   x
 *     / \                 / \
 *    x  ry   ----->      lx  y
 *   / \                     / \
 * lx  rx                   rx ry
 * 右旋做了三件事：
 * 1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时)
 * 2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右)
 * 3. 将x的右子节点设为y，将y的父节点设为x
 */
func (y *node) rightRotate(tree *RBTree) {
	if y == nil || y.left == nil {
		return
	}
	x, rx, p := y.left, y.left.right, y.parent
	x.right, x.parent, y.left, y.parent = y, p, rx, x
	if p == nil {
		tree.root = x
	} else if p.left == y {
		p.left = x
	} else {
		p.right = x
	}
	return
}
```
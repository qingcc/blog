# 概念
乐观锁和悲观锁并不是一种真实存在的锁，而是一种设计思想

## 悲观锁
`悲观锁` 是一种悲观思想，它总认为最坏的情况可能会出现，它认为数据很可能会被其他人所修改，
所以悲观锁在持有数据的时候总会把`资源` 或者 `数据` 锁住，这样其他线程想要请求这个资源的时候就会阻塞，
直到等到悲观锁把资源释放为止。传统的关系型数据库里边就用到了很多这种锁机制，`比如行锁，表锁等，
读锁，写锁等，都是在做操作之前先上锁`。悲观锁的实现往往依靠数据库本身的锁功能实现

## 乐观锁
`乐观锁` 的思想与悲观锁的思想相反，它总认为资源和数据不会被别人所修改，所以读取不会上锁，
但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过。乐观锁的实现方案一般来说有两种：
`版本号机制` 和 `CAS实现` 。乐观锁多适用于多读的应用类型，这样可以提高吞吐量。

## 两种锁的使用场景

一般来说，悲观锁不仅会对写操作加锁还会对读操作加锁，一个典型的悲观锁调用：
```sql
select * from student where name="cxuan" for update
```

这条 sql 语句从 Student 表中选取 name = "cxuan" 的记录并对其加锁，
那么其他写操作再这个事务提交之前都不会对这条数据进行操作，起到了独占和排他的作用。

悲观锁因为对读写都加锁，所以它的性能比较低，对于现在互联网提倡的三高(高性能、高可用、高并发)
来说，悲观锁的实现用的越来越少了，但是一般多读的情况下还是需要使用悲观锁的，因为虽然加锁的性能
比较低，但是也阻止了像乐观锁一样，遇到写不一致的情况下一直重试的时间。

相对而言，乐观锁用于读多写少的情况，即很少发生冲突的场景，这样可以省去锁的开销，增加系统的吞吐量。

## 乐观锁的缺点

- ABA 问题: 

一个值从 A 变为 B ，又从 B 变回了 A，
这种情况下，CAS 会认为值没有发生过变化，但实际上是有变化的

- 循环开销大: 

我们知道乐观锁在进行写操作的时候会判断是否能够写入成功，如果写入不成功将触发等待 -> 重试机制，
这种情况是一个自旋锁，简单来说就是适用于短期内获取不到，进行等待重试的锁，它不适用于长期获取
不到锁的情况，另外，自旋循环对于性能开销比较大。
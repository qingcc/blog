[原文链接](https://www.jb51.net/article/151374.htm)

> 在开发过程中往往需要配合单元测试，但是很多时候，单元测试需要依赖一些比较复杂的准备工作，比如需要依赖数据库环境，需要依赖网络环境，单元测试就变成了一件非常麻烦的事情。举例来说，比如我们需要请求一个网页，并将请求回来的数据进行处理。在刚开始的时候，我通常都会先启动一个简单的http服务，然后再运行我的单元测试。可是这个单元测试测起来似乎非常笨重。甚至在持续集成过程中，我还为了能够自动化测试，特意写了一个脚本自动启动相应的服务。事情似乎需要进行一些改变。
> 
> mock对象就是为了解决上面的问题而诞生的，mock(模拟)对象能够模拟实际依赖对象的功能，同时又不需要非常复杂的准备工作，你需要做的，仅仅就是定义对象接口，然后实现它，再交给测试对象去使用。
> 
> `go-mock`是专门为go语言开发的mock库，该库使用方式简单，支持自动生成代码，可以说是不可多得的好工具。

# 安装gomock


```
go get -u github.com/golang/mock/gomock
go install github.com/golang/mock/mockgen
```
- 第一步：我们将安装 gomock 第三方库和 mock 代码的生成工具 mockgen。而后者可以大大的节省我们的工作量。只需要了解其使用方式就可以

- 第二步：输入 mockgen 验证代码生成工具是否安装正确。若无法正常响应，请检查 bin 目录下是否包含该二进制文件

## 用法
在 mockgen 命令中，支持两种生成模式：

- source：从源文件生成 mock 接口（通过 `-source` 启用）

```
mockgen -source=foo.go [other options]
```

- reflect：通过使用反射程序来生成 mock 接口。它通过传递两个非标志参数来启用：导入路径和逗号分隔的接口列表


```
mockgen database/sql/driver Conn,Driver
```

从本质上来讲，两种方式生成的 mock 代码并没有什么区别。因此选择合适的就可以了

## 写测试用例
在本文将模拟一个简单 Demo 来编写测试用例，熟悉整体的测试流程

### 步骤

- 想清楚整体逻辑
- 定义想要（模拟）依赖项的 interface（接口）
- 使用 mockgen 命令对所需 mock 的 interface 生成 mock 文件
- 编写单元测试的逻辑，在测试中使用 mock
- 进行单元测试的验证

### 目录
```
├── mock
├── person
│  └── male.go
└── user
  ├── user.go
  └── user_test.go
```

### 编写

#### interface 方法
打开 `person/male.go` 文件，写入以下内容：

```
package person
 
type Male interface {
  Get(id int64) error
}
```

#### 调用方法
打开 `user/user.go` 文件，写入以下内容：

```
package user
 
import "github.com/EDDYCJY/mockd/person"
 
type User struct {
  Person person.Male
}
 
func NewUser(p person.Male) *User {
  return &User{Person: p}
}
 
func (u *User) GetUserInfo(id int64) error {
  return u.Person.Get(id)
}
```

#### 生成 mock 文件

回到 `mock/` 的根目录下，执行以下命令

```
 mockgen -source=./person/male.go -destination=./mock/male_mock.go -package=mock
```

在执行完毕后，可以发现 mock/ 目录下多出了 male_mock.go 文件，这就是 mock 文件。那么命令中的指令又分别有什么用呢？如下：

> -source：设置需要模拟（mock）的接口文件
> 
> -destination：设置 mock 文件输出的地方，若不设置则打印到标准输出中
> 
> -package：设置 mock 文件的包名，若不设置则为 mock_ 前缀加上文件名（如本文的包名会为 mock_person）

想了解更多的指令符，可参见 [官方文档](https://godoc.org/github.com/golang/mock/gomock#pkg-index)

输出的 mock 文件

```
// Code generated by MockGen. DO NOT EDIT.
// Source: ./person/male.go
 
// Package mock is a generated GoMock package.
package mock
 
import (
  gomock "github.com/golang/mock/gomock"
  reflect "reflect"
)
 
// MockMale is a mock of Male interface
type MockMale struct {
  ctrl   *gomock.Controller
  recorder *MockMaleMockRecorder
}
 
// MockMaleMockRecorder is the mock recorder for MockMale
type MockMaleMockRecorder struct {
  mock *MockMale
}
 
// NewMockMale creates a new mock instance
func NewMockMale(ctrl *gomock.Controller) *MockMale {
  mock := &MockMale{ctrl: ctrl}
  mock.recorder = &MockMaleMockRecorder{mock}
  return mock
}
 
// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockMale) EXPECT() *MockMaleMockRecorder {
  return m.recorder
}
 
// Get mocks base method
func (m *MockMale) Get(id int64) error {
  ret := m.ctrl.Call(m, "Get", id)
  ret0, _ := ret[0].(error)
  return ret0
}
 
// Get indicates an expected call of Get
func (mr *MockMaleMockRecorder) Get(id interface{}) *gomock.Call {
  return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockMale)(nil).Get), id)
}
```

#### 测试用例
打开 `user/user_test.go` 文件，写入以下内容：


```
package user
 
import (
  "testing"
 
  "github.com/EDDYCJY/mockd/mock"
 
  "github.com/golang/mock/gomock"
)
 
func TestUser_GetUserInfo(t *testing.T) {
  ctl := gomock.NewController(t)
  defer ctl.Finish()
 
  var id int64 = 1
  mockMale := mock.NewMockMale(ctl)
  gomock.InOrder(
    mockMale.EXPECT().Get(id).Return(nil),
  )
 
  user := NewUser(mockMale)
  err := user.GetUserInfo(id)
  if err != nil {
    t.Errorf("user.GetUserInfo err: %v", err)
  }
}
```

- gomock.NewController：返回 gomock.Controller，它代表 mock 生态系统中的顶级控件。定义了 mock 对象的范围、生命周期和期待值。另外它在多个 goroutine 中是安全的
- mock.NewMockMale：创建一个新的 mock 实例
- gomock.InOrder：声明给定的调用应按顺序进行（是对 gomock.After 的二次封装）
- mockMale.EXPECT().Get(id).Return(nil)：这里有三个步骤，EXPECT()返回一个允许调用者设置期望和返回值的对象。Get(id) 是设置入参并调用 mock 实例中的方法。Return(nil) 是设置先前调用的方法出参。简单来说，就是设置入参并调用，最后设置返回值
- NewUser(mockMale)：创建 User 实例，值得注意的是，在这里注入了 mock 对象，因此实际在随后的 user.GetUserInfo(id) 调用（入参：id 为 1）中。它调用的是我们事先模拟好的 mock 方法
- ctl.Finish()：进行 mock 用例的期望值断言，一般会使用 defer 延迟执行，以防止我们忘记这一操作

#### 测试

回到 `mock/` 的根目录下，执行以下命令


```
go test ./user 
#output
ok   github.com/EDDYCJY/mockd/user
```
看到这样的结果，就大功告成啦！你可以自己调整一下 Return() 的返回值，以此得到不一样的测试结果哦😄

### 查看测试情况

#### 测试覆盖率

生成测试覆盖率的 profile 文件

```
go test ./... -coverprofile=cover.out
```

利用 profile 文件生成可视化界面

```
go tool cover -html=cover.out
```

## 更多

### 常用 mock 方法
#### 调用方法

- Call.Do()：声明在匹配时要运行的操作
- Call.DoAndReturn()：声明在匹配调用时要运行的操作，并且模拟返回该函数的返回值
- Call.MaxTimes()：设置最大的调用次数为 n 次
- Call.MinTimes()：设置最小的调用次数为 n 次
- Call.AnyTimes()：允许调用次数为 0 次或更多次
- Call.Times()：设置调用次数为 n 次

#### 参数匹配

- gomock.Any()：匹配任意值
- gomock.Eq()：通过反射匹配到指定的类型值，而不需要手动设置
- gomock.Nil()：返回 nil

### 生成多个 mock 文件

你可能会想一条条命令生成 mock 文件，岂不得崩溃？

当然，官方提供了更方便的方式，我们可以利用 go:generate 来完成批量处理的功能
```
go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]
```
修改 interface 方法
打开 `person/male.go` 文件，修改为以下内容：
```
package person

//go:generate mockgen -destination=../mock/male_mock.go -package=mock github.com/EDDYCJY/mockd/person Male

type Male interface {
    Get(id int64) error
}
```
我们关注到 `go:generate` 这条语句，可分为以下部分：

- 声明 //go:generate （注意不要留空格）
- 使用 mockgen 命令
- 定义 -destination
- 定义 -package
- 定义 source，此处为 person 的包路径
- 定义 interfaces，此处为 Male

#### 重新生成 mock 文件

回到 mock/ 的根目录下，执行以下命令
```
$ go generate ./...
```
再检查 mock/ 发现也已经正确生成了，在多个文件时是不是很方便呢 🤩

## 总结
在单元测试这一环，gomock 给我们提供了极大的便利。能够 mock 掉许许多多的依赖项

其中还有很多的使用方式和功能。你可以 mark 住后详细阅读下官方文档，记忆会更深刻
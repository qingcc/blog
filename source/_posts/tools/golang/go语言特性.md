# go 语言特性

## 并发编程
Go语言在并发编程方面比绝大多数语言要简洁不少，这一点是其最大亮点之一，也是其在未来进入高并发高性能场景的重要筹码。
![Image](https://user-gold-cdn.xitu.io/2019/3/28/169c2e7fb64e8d90?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

不同于传统的多进程或多线程，golang的并发执行单元是一种称为goroutine的协程。

由于在共享数据场景中会用到锁，再加上GC，其并发性能有时不如异步复用IO模型，因此相对于大多数语言来说，
golang的并发编程简单比并发性能更具卖点。

在当今这个多核时代，并发编程的意义不言而喻。当然，很多语言都支持多线程、多进程编程，但遗憾的是，
实现和控制起来并不是那么令人感觉轻松和愉悦。Golang不同的是，语言级别支持协程(goroutine)并发
（协程又称微线程，比线程更轻量、开销更小，性能更高），操作起来非常简单，语言级别提供关键字（go）
用于启动协程，并且在同一台机器上可以启动成千上万个协程。协程经常被理解为轻量级线程，一个线程可以包含多个协程，
共享堆不共享栈。协程间一般由应用程序显式实现调度，上下文切换无需下到内核层，高效不少。协程间一般不做同步通讯，
而golang中实现协程间通讯有两种：
1）共享内存型，即使用全局变量+mutex锁来实现数据共享；
2）消息传递型，即使用一种独有的channel机制进行异步通讯。

**高并发是Golang语言最大的亮点**


##  内存回收(GC)
从C到C++，从程序性能的角度来考虑，这两种语言允许程序员自己管理内存，包括内存的申请和释放等。
因为没有垃圾回收机制所以C/C++运行起来速度很快，但是随着而来的是程序员对内存使用上的很谨小慎微的考虑。
因为哪怕一点不小心就可能会导致“内存泄露”使得资源浪费或者“野指针”使得程序崩溃等，尽管C++11后来使用了智能指针的概念，
但是程序员仍然需要很小心的使用。后来为了提高程序开发的速度以及程序的健壮性，java和C#等高级语言引入了GC机制，
即程序员不需要再考虑内存的回收等，而是由语言特性提供垃圾回收器来回收内存。但是随之而来的可能是程序运行效率的降低。

GC过程是：先stop the world，扫描所有对象判活，把可回收对象在一段bitmap区中标记下来，接着立即start the world，
恢复服务，同时起一个专门gorountine回收内存到空闲list中以备复用，不物理释放。物理释放由专门线程定期来执行。

GC瓶颈在于每次都要扫描所有对象来判活，待收集的对象数目越多，速度越慢。一个经验值是扫描10w个对象需要花费1ms，
所以尽量使用对象少的方案，比如我们同时考虑链表、map、slice、数组来进行存储，链表和map每个元素都是一个对象
，而slice或数组是一个对象，因此slice或数组有利于GC。

GC性能可能随着版本不断更新会不断优化

- 内存自动回收，再也不需要开发人员管理内存
- 开发人员专注业务实现，降低了心智负担
- 只需要new分配内存，不需要释放

## 内存分配
初始化阶段直接分配一块大内存区域，大内存被切分成各个大小等级的块，放入不同的空闲list中，
对象分配空间时从空闲list中取出大小合适的内存块。内存回收时，会把不用的内存重放回空闲list。
空闲内存会按照一定策略合并，以减少碎片。

## 编译
编译涉及到两个问题：编译速度和依赖管理
编译速度快，编译时会默认检查代码中所有实体的使用情况。一旦编译成功就是一个可执行文件，没有其他依赖。

## 网络编程
由于golang诞生在互联网时代，因此它天生具备了去中心化、分布式等特性，具体表现之一就是提供了丰富便捷的网络编程接口，
比如socket用net.Dial(基于tcp/udp，封装了传统的connect、listen、accept等接口)、http用http.Get/Post()、
rpc用client.Call('class_name.method_name', args, &reply)，等等。

## “包”的概念
和python一样，把相同功能的代码放到一个目录，称之为包。包可以被其他包引用。main包是用来生成可执行文件，
每个程序只有一个main包。包的主要用途是提高代码的可复用性。通过package可以引入其他包。

## 编程规范
GO语言的编程规范强制集成在语言中，代码简洁，格式统一，阅读方便，这样更直接，更有利于团队协作和工程管理。
   
## defer机制
在Go语言中，提供关键字defer，可以通过该关键字指定需要延迟执行的逻辑体，即在函数体return前或出现panic时执行。
这种机制非常适合善后逻辑处理，比如可以尽早避免可能出现的资源泄漏问题。

可以说，defer是继goroutine和channel之后的另一个非常重要、实用的语言特性，对defer的引入，
在很大程度上可以简化编程，并且在语言描述上显得更为自然，极大的增强了代码的可读性。
   
## 易学性
Go学习门槛很低，丰富的标准库，Go目前已经内置了大量的库，特别是网络库非常强大。

## 缺少泛型
缺少泛型，完全相同的逻辑，只是因为入参不同而需要复制实现多次，导致出现大量重复代码。
但是官方已经确定泛型是go2的发展路线中的重中之重,即将在新的版本中实现

## 错误处理
错误处理一般采用`if err != nil { return err }`来返回错误，导致代码中出现大量的该类和逻辑无关的代码

## 丰富实用的内置数据类型

## 函数多返回值